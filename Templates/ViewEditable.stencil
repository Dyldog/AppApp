import SwiftUI

{% macro EditableProperties type %}
extension {{ type.name }} {
	 enum Properties: String, ViewProperty {
        {% for property in type.storedVariables %}
            {% if not property.defaultValue %}
        case {{ property.name }}
            {% endif %}
        {% endfor %}
        
        var defaultValue: any EditableVariableValue {
            switch self {
        {% for property in type.storedVariables %}
            {% if not property.defaultValue %}
            case .{{ property.name }}: return {{ type.name }}.defaultValue{% if type.implements.CompositeEditableVariableValue %}(for: .{{ property.name }}){% endif %}
            {% endif %}
        {% endfor %}
            }
        }
    }
     
    static func make(factory: (Properties) -> any EditableVariableValue) -> {{ type.name }} {
        .init(
    {% for property in type.storedVariables %}
        {% if not property.defaultValue %}
            {{ property.name }}: factory(.{{ property.name }}) as! {{ property.typeName }}{{ ',' if not forloop.last }}
        {% endif %}
    {% endfor %}
        )
    }

    static func makeDefault() -> {{ type.name }} {
        .init(
    {% for property in type.storedVariables %}
        {% if not property.defaultValue %}
            {{ property.name }}: Properties.{{ property.name }}.defaultValue as! {{ property.typeName }}{{ ',' if not forloop.last }}
        {% endif %}
    {% endfor %}
		)
    }
    
    func value(for property: Properties) -> any EditableVariableValue {
    {% for property in type.storedVariables where not property.defaultValue %}
        {% if forloop.first %}
		switch property {
        {% endif %}
	        case .{{ property.name }}: return {{ property.name }}
        {% if forloop.last %}
        }
        {% endif %}
    {% endfor %}
    }

	func set(_ value: Any, for property: Properties) {
    {% for property in type.storedVariables where not property.defaultValue %}
        {% if forloop.first %}
		switch property {
        {% endif %}
	        case .{{ property.name }}: self.{{ property.name }} = value as! {{ property.typeName }}
        {% if forloop.last %}
	    }
        {% endif %}
    {% endfor %}
	}
}
{% endmacro %}

{% for type in types.implementing.EditableVariableValue|!protocol %}
    {% if type.implements.CompositeEditableVariableValue %}
        {% call EditableProperties type %}
    {% endif %}
{% endfor %}

extension CodableMakeableList: Codable {
	init(from decoder: Decoder) throws {
        var contentContainer = try decoder.unkeyedContainer()
        
        var content: [any MakeableView] = []
        
        while !contentContainer.isAtEnd {
{% for type in types.implementing.MakeableView|!protocol %}
            {{ 'else ' if not forloop.first }}if let value = try? contentContainer.decode({{ type.name }}.self) {
                content.append(value)
            }  
{% endfor %}
            else {
                self.init(elements: [MakeableLabel.withText("ERROR")])
                return
            }
        }
        
        self.init(elements: content)
    }
    
    func encode(to encoder: Encoder) throws {
        var contentContainer = encoder.unkeyedContainer()
        
        for element in elements {
            switch element {
{% for type in types.implementing.MakeableView|!protocol %}
            case let value as {{ type.name }}:
                try contentContainer.encode(value)
{% endfor %}
            default:
                fatalError()
            }
        }
    }
}

extension CodableVariableValue: Codable {
	enum CodingKeys: String, CodingKey {
        case type
        case value
    }

    init(from decoder: Decoder) throws {
        let valueContainer = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try valueContainer.decode(String.self, forKey: .type)
        
        switch type {
{% for type in types.implementing.VariableValue|!protocol %}
        case typeString({{ type.name }}.self):
            self.value = try valueContainer.decode({{ type.name }}.self, forKey: .value)
{% endfor %}
        default:
            fatalError(type)
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(type, forKey: .type)
        
        switch self.value {
{% for type in types.implementing.VariableValue|!protocol %}
        case let value as {{ type.name }}:
            try container.encode(value, forKey: .value)
{% endfor %}
        default: fatalError()
        }
    }
}

extension AddViewViewModel {
	convenience init(onSelect: @escaping (any MakeableView) -> Void) {
		self.init(rows: [
{% for type in types.implementing.MakeableView|!protocol %}
            .init(title: "{{ type.name|replace:"Makeable","" }}", onTap: {
                onSelect({{ type.name }}.makeDefault())
            }){{ ',' if not forloop.last }}
{% endfor %}
        ])
	}
}

{% macro VariableTypeName type %}{% if type|annotated:"variableTypeName" %}{{ type.annotations.variableTypeName }}{% else %}{{ type.name|replace:"Value",""|replace:"Makeable",""|lowerFirstLetter }}{% endif %}{% endmacro %}

enum VariableType: String, CaseIterable, Equatable, Codable, Titleable {   
{% for type in types.implementing.EditableVariableValue|!protocol %}
{% if not type.implements.StepType %}
	case {%+ call VariableTypeName type +%} // {{ type.name }}
{% endif %}
{% endfor %}

	var defaultView: any EditableVariableValue {
        switch self {
{% for type in types.implementing.EditableVariableValue|!protocol %}
{% if not type.implements.StepType %}
        case .{%+ call VariableTypeName type +%}: return {{ type.name }}.makeDefault()
{% endif %}
{% endfor %}
        }
    }
    
    var title: String {
        switch self {
        {% for type in types.implementing.EditableVariableValue|!protocol %}
        {% if not type.implements.StepType %}
        case .{%+ call VariableTypeName type +%}: return "{%+ call VariableTypeName type +%}"
        {% endif %}
    {% endfor %}
        }
    }
}

extension MakeableWrapperView {
	var body: some View {
        switch view {
{% for type in types.implementing.MakeableView|!protocol %}
        case let value as {{ type.name }}:
            {{ type.name }}View(isRunning: isRunning, showEditControls: showEditControls, {%+ call VariableTypeName type +%}: value, onContentUpdate: onContentUpdate, onRuntimeUpdate: onRuntimeUpdate).any
{% endfor %}
        default:
            Text("UNKNOWN VIEW").any
        }
    }
}

{% macro StepCaseName step %}{{ type.name|replace:"Step", ""}}{% endmacro %}

extension AddActionView {
	enum Actions: Int, CaseIterable {
{% for type in types.implementing.StepType|!protocol %}
		case {% call StepCaseName type %}
{% endfor %}
        
        var title: String {
            switch self {
{% for type in types.implementing.StepType|!protocol %}
            case .{% call StepCaseName type %}: return {{ type.name }}.title
{% endfor %}
            }
        }
        
        func make() -> any StepType {
            switch self {
{% for type in types.implementing.StepType|!protocol %}
            case .{% call StepCaseName type %}: {{ type.name}}.makeDefault()
{% endfor %}
            }
        }
    }
    
    
}

extension CodableStep: Codable {
	init(from decoder: Decoder) throws {
        let valueContainer = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try valueContainer.decode(String.self, forKey: .type)
        
        switch type {
{% for type in types.implementing.StepType|!protocol %}
        case typeString({{ type.name }}.self):
			self.value = try valueContainer.decode({{ type.name }}.self, forKey: .value)
{% endfor %}
        default:
            fatalError(type)
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(type, forKey: .type)
        
        switch self.value {
{% for type in types.implementing.StepType|!protocol %}
		case let value as {{ type.name }}:
			try container.encode(value, forKey: .value)
{% endfor %}
        default: fatalError()
        }
    }
}
