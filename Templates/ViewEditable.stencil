import SwiftUI
import Armstrong

{% macro EditableProperties type %}
extension {{ type.name }} {
	 enum Properties: String, ViewProperty {
        {% for property in type.storedVariables %}
            {% if not property.defaultValue %}
        case {{ property.name }}
            {% endif %}
        {% endfor %}
        
        var defaultValue: any EditableVariableValue {
            switch self {
        {% for property in type.storedVariables %}
            {% if not property.defaultValue %}
            case .{{ property.name }}: return {{ type.name }}.defaultValue{% if type.implements.CompositeEditableVariableValue %}(for: .{{ property.name }}){% endif %}
            {% endif %}
        {% endfor %}
            }
        }
    }
     
    static func make(factory: (Properties) -> any EditableVariableValue) -> Self {
        .init(
    {% for property in type.storedVariables %}
        {% if not property.defaultValue %}
            {{ property.name }}: factory(.{{ property.name }}) as! {{ property.typeName }}{{ ',' if not forloop.last }}
        {% endif %}
    {% endfor %}
        )
    }

    static func makeDefault() -> Self {
        .init(
    {% for property in type.storedVariables %}
        {% if not property.defaultValue %}
            {{ property.name }}: Properties.{{ property.name }}.defaultValue as! {{ property.typeName }}{{ ',' if not forloop.last }}
        {% endif %}
    {% endfor %}
		)
    }
    
    func value(for property: Properties) -> any EditableVariableValue {
    {% for property in type.storedVariables where not property.defaultValue %}
        {% if forloop.first %}
		switch property {
        {% endif %}
	        case .{{ property.name }}: return {{ property.name }}
        {% if forloop.last %}
        }
        {% endif %}
    {% endfor %}
    }

	func set(_ value: Any, for property: Properties) {
    {% for property in type.storedVariables where not property.defaultValue %}
        {% if forloop.first %}
		switch property {
        {% endif %}
	        case .{{ property.name }}: self.{{ property.name }} = value as! {{ property.typeName }}
        {% if forloop.last %}
	    }
        {% endif %}
    {% endfor %}
	}
}
{% endmacro %}

{% for type in types.implementing.EditableVariableValue|!protocol %}
    {% if type.implements.CompositeEditableVariableValue and type|!annotated:"skipVariableType" %}
        {% call EditableProperties type %}
    {% endif %}
{% endfor %}

extension CodableVariableValue: Codable {
	enum CodingKeys: String, CodingKey {
        case type
        case value
    }

    init(from decoder: Decoder) throws {
        let valueContainer = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try valueContainer.decode(String.self, forKey: .type)
        
{% macro VariableCodableCase type %}
{% if type|!annotated:"skipCodable" %}
        case typeString({{ type.name }}.self):
            self.value = try valueContainer.decode({{ type.name }}.self, forKey: .value)
{% endif %}
{% endmacro %}

{% macro OtherCodableCase type %}
{% if type|!annotated:"skipCodable" %}
        case typeString({{ type.name|replace:".", "" }}Value.self):
            self.value = try valueContainer.decode({{ type.name|replace:".", "" }}Value.self, forKey: .value)
{% endif %}
{% endmacro %}

        switch type {
{% for type in types.implementing.VariableValue|!protocol %}
{% call VariableCodableCase type %}
{% endfor %}
{% for type in types.implementing.PickableValue|!protocol %}
{% call OtherCodableCase type %}
{% endfor %}
{% for type in types.implementing.StringRepresentableValue|!protocol %}
{% call OtherCodableCase type %}
{% endfor %}

        default:
            fatalError(type)
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(type, forKey: .type)
        
        switch self.value {
{% for type in types.implementing.VariableValue|!protocol %}
    {% if type|!annotated:"skipCodable" %}
        case let value as {{ type.name }}:
            try container.encode(value, forKey: .value)
    {% endif %}
{% endfor %}

{% for type in types.implementing.PickableValue|!protocol %}
    {% if type|!annotated:"skipCodable" %}
        case let value as {{ type.name|replace:".", "" }}Value:
            try container.encode(value, forKey: .value)
    {% endif %}
{% endfor %}

{% for type in types.implementing.StringRepresentableValue|!protocol %}
    {% if type|!annotated:"skipCodable" %}
        case let value as {{ type.name|replace:".", "" }}Value:
            try container.encode(value, forKey: .value)
    {% endif %}
{% endfor %}

        default: fatalError()
        }
    }
}

extension AddViewViewModel {
	convenience init(onSelect: @escaping (any MakeableView) -> Void) {
		self.init(rows: [
{% for type in types.implementing.MakeableView|!protocol %}
        {% if type.kind != "protocolComposition" %}

            .init(title: "{{ type.name|replace:"Makeable","" }}", onTap: {
                onSelect({{ type.name }}.makeDefault())
            }){{ ',' if not forloop.last }}
        {% endif %}
{% endfor %}
        ])
	}
}

{% macro TypeNameCase type %}{{ type.name|replace:".", ""|lowerFirstLetter }}{% endmacro %}
{% macro TypeNameCaseType type %}{{ type.name|replace:".", "" }}{% endmacro %}

{% macro VariableTypeName type %}{% if type|annotated:"variableTypeName" %}{{ type.annotations.variableTypeName }}{% else %}{{ type.name|replace:"Value",""|replace:"Makeable",""|lowerFirstLetter }}{% endif %}{% endmacro %}

extension VariableType {

{% for type in types.implementing.EditableVariableValue|!protocol %}
    {% if not type.implements.StepType %}
        {% if type|!annotated:"skipVariableType" %}
	static var {%+ call VariableTypeName type +%}: VariableType { .init() } // {{ type.name }}
        {% endif %}
    {% endif %}
{% endfor %}

{% for type in types.implementing.PickableValue|!protocol %}
    {% if type|!annotated:"skipVariableType" %}
        static var {%+ call TypeNameCase type +%}: VariableType { .init() } // {{ type.name }}
    {% endif %}
{% endfor %}

{% for type in types.implementing.StringRepresentableValue|!protocol %}
    {% if type|!annotated:"skipVariableType" %}
        static var {%+ call TypeNameCase type +%}: VariableType { .init() } // {{ type.name }}
    {% endif %}
{% endfor %}
}

extension MakeableWrapperView {
	var body: some View {
        ZStack {
            inner
        }
    }
    
    var inner: some View {
        switch view {
        {% for type in types.implementing.MakeableView|!protocol %}
        {% if type.kind != "protocolComposition" %}
        case let value as {{ type.name }}:
            return {{ type.name }}View(isRunning: isRunning, showEditControls: showEditControls, {%+ call VariableTypeName type +%}: value, onContentUpdate: onContentUpdate, onRuntimeUpdate: onRuntimeUpdate, error: $error).any
        {% endif %}
        {% endfor %}
        default:
            return Text("UNKNOWN VIEW").any
        }
    }
}

{% macro StepCaseName step %}{{ type.name|replace:"Step", ""}}{% endmacro %}

extension AddActionView {
	enum Actions: Int, CaseIterable {
{% for type in types.implementing.StepType|!protocol %}
		case {% call StepCaseName type %}
{% endfor %}
        
        var title: String {
            switch self {
{% for type in types.implementing.StepType|!protocol %}
            case .{% call StepCaseName type %}: return {{ type.name }}.title
{% endfor %}
            }
        }
        
        func make() -> any StepType {
            switch self {
{% for type in types.implementing.StepType|!protocol %}
            case .{% call StepCaseName type %}: {{ type.name}}.makeDefault()
{% endfor %}
            }
        }
    }
    
    
}

extension CodableStep: Codable {
	init(from decoder: Decoder) throws {
        let valueContainer = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try valueContainer.decode(String.self, forKey: .type)
        
        switch type {
{% for type in types.implementing.StepType|!protocol %}
        case typeString({{ type.name }}.self):
			self.value = try valueContainer.decode({{ type.name }}.self, forKey: .value)
{% endfor %}
        default:
            fatalError(type)
        }
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(type, forKey: .type)
        
        switch self.value {
{% for type in types.implementing.StepType|!protocol %}
		case let value as {{ type.name }}:
			try container.encode(value, forKey: .value)
{% endfor %}
        default: fatalError()
        }
    }
}
